// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  self.addEventListener("message", function(event) {
    var TwoDimensionalArray, collectify, getJSON, toBins;
    if (event.data.cmd === "stop") {
      return self.close();
    } else if (event.data.cmd === "start") {
      importScripts("/bower_components/lodash/dist/lodash.min.js");
      TwoDimensionalArray = (function(_super) {
        __extends(TwoDimensionalArray, _super);

        function TwoDimensionalArray(dim1size, dim2size, value) {
          var arr, i, j, _i, _j;
          if (value == null) {
            value = "";
          }
          for (i = _i = 0; 0 <= dim1size ? _i < dim1size : _i > dim1size; i = 0 <= dim1size ? ++_i : --_i) {
            arr = [];
            for (j = _j = 0; 0 <= dim2size ? _j < dim2size : _j > dim2size; j = 0 <= dim2size ? ++_j : --_j) {
              arr.push(typeof value === "function" ? value(i, j) : value);
            }
            this.push(arr);
          }
        }

        TwoDimensionalArray.prototype.forEach = function(callback) {
          var i, item, j, row, _i, _j, _len, _len1, _ref;
          for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
            row = this[i];
            _ref = this[0];
            for (j = _j = 0, _len1 = _ref.length; _j < _len1; j = ++_j) {
              item = _ref[j];
              callback(item, i, j, this);
            }
          }
          return this;
        };

        TwoDimensionalArray.prototype.each = function() {
          return this.forEach(arguments);
        };

        TwoDimensionalArray.prototype.map = function(callback) {
          var i, item, j, map, row, _i, _j, _len, _len1;
          map = new TwoDimensionalArray(this.length, this[0].length);
          for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
            row = this[i];
            for (j = _j = 0, _len1 = row.length; _j < _len1; j = ++_j) {
              item = row[j];
              map[i][j] = callback(item, i, j, this);
            }
          }
          return map;
        };

        return TwoDimensionalArray;

      })(Array);
      collectify = function(headers, arrays) {
        var array, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arrays.length; _i < _len; _i++) {
          array = arrays[_i];
          _results.push(_.object(headers, array));
        }
        return _results;
      };
      toBins = function(data, optHash) {
        var bins, d1, d2, datum, dim1, dim1maxBin, dim1minBin, dim1range, dim1size, dim1vals, dim2, dim2maxBin, dim2minBin, dim2range, dim2size, dim2vals, _i, _len;
        dim1 = optHash.dim1;
        dim2 = optHash.dim2;
        dim1vals = _.pluck(data, dim1);
        dim2vals = _.pluck(data, dim2);
        dim1range = [_.min(dim1vals), _.max(dim1vals)];
        dim2range = [_.min(dim2vals), _.max(dim2vals)];
        dim1size = optHash.dim1size || ((dim1range[0] - dim1range[1]) / dim1len);
        dim2size = optHash.dim2size || ((dim2range[0] - dim2range[1]) / dim2len);
        dim1minBin = Math.floor(dim1range[0] / size);
        dim1maxBin = Math.ceil(dim1range[1] / size);
        dim2minBin = Math.floor(dim2range[0] / size);
        dim2maxBin = Math.ceil(dim2range[1] / size);
        bins = new TwoDimensionalArray(1 + dim1maxBin - dim1minBin, 1 + dim2maxBin - dim2minBin, (function() {
          return [];
        }));
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          datum = data[_i];
          d1 = (~~(datum[dim1] / size)) + Math.abs(dim1minBin);
          d2 = (~~(datum[dim2] / size)) + Math.abs(dim2minBin);
          bins[d1][d2].push(datum);
        }
        return bins;
      };
      getJSON = function(url, success, fail) {
        var data, opts, request;
        if (typeof url === "object") {
          opts = url;
          url = opts.url;
          data = opts.data || {};
        }
        request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.onload = function() {
          if (request.status >= 200 && request.status < 400) {
            return success(JSON.parse(request.responseText));
          } else {
            return fail(request, request.status);
          }
        };
        request.onerror = function() {
          throw new Error("AJAX request to " + url + " couldn't reach server.");
        };
        return request.send(data);
      };
      return getJSON(event.data.msg.ajaxData, function(data) {
        var binOpts, cleanShooting, minimalBins, pctBins, rawShootingCollection, shotBins, threshold;
        rawShootingCollection = collectify(data.resultSets[0].headers, data.resultSets[0].rowSet);
        cleanShooting = [];
        rawShootingCollection.forEach(function(shot) {
          var newShot;
          newShot = {};
          newShot.m = shot.SHOT_MADE_FLAG;
          newShot.x = shot.LOC_X;
          newShot.y = shot.LOC_Y;
          newShot.v = parseInt(shot.SHOT_TYPE.charAt(0));
          return cleanShooting.push(newShot);
        });
        binOpts = {
          dim1: "x",
          dim2: "y",
          dim1size: 10,
          dim2size: 10
        };
        shotBins = toBins(cleanShooting, binOpts);
        pctBins = shotBins.map(function(shots, x, y) {
          var bin, made, total;
          if (shots.length) {
            bin = {};
            total = shots.length;
            made = shots.filter(function(s) {
              return s.m;
            }).length;
            bin.a = shots.length;
            bin.p = parseFloat(made / total).toFixed(4);
            bin.x = x;
            bin.y = y;
            bin.v = shots[0].v;
            return bin;
          } else {
            return false;
          }
        });
        threshold = event.data.msg.attThreshold || 1;
        minimalBins = _(pctBins).flatten().filter(function(b) {
          return b.a >= threshold;
        }).value();
        return self.postMessage(JSON.stringify(minimalBins));
      }, function(req, status) {
        throw new Error("Server responded with status " + status);
      });
    }
  });

}).call(this);
