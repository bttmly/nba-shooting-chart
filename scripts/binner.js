// Generated by CoffeeScript 1.7.1
(function() {
  var collectify, dataToBins, toBins;

  self.addEventListener("message", function(event) {
    if (event.data.cmd === "stop") {
      return self.close();
    } else if (event.data.cmd === "start") {
      importScripts("/bower_components/lodash/dist/lodash.min.js", "two-dim-arr.js");
      return dataToBins(event.data.msg);
    }
  });

  collectify = function(headers, arrays) {
    var array, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = arrays.length; _i < _len; _i++) {
      array = arrays[_i];
      _results.push(_.object(headers, array));
    }
    return _results;
  };

  toBins = function(data, optHash) {
    var bins, d1, d2, datum, dim1, dim1maxBin, dim1minBin, dim1range, dim1size, dim2, dim2maxBin, dim2minBin, dim2range, dim2size, _i, _len;
    dim1 = optHash.dim1;
    dim2 = optHash.dim2;
    dim1range = optHash.dim1range || [_.min(_.pluck(data, dim1)), _.max(_.pluck(data, dim1))];
    dim2range = optHash.dim2range || [_.min(_.pluck(data, dim2)), _.max(_.pluck(data, dim2))];
    dim1size = parseInt(optHash.dim1size, 10) || ((dim1range[0] - dim1range[1]) / optHash.dim1len);
    dim2size = parseInt(optHash.dim2size, 10) || ((dim2range[0] - dim2range[1]) / optHash.dim2len);
    dim1minBin = Math.floor(dim1range[0] / dim1size);
    dim1maxBin = Math.ceil(dim1range[1] / dim1size);
    dim2minBin = Math.floor(dim2range[0] / dim2size);
    dim2maxBin = Math.ceil(dim2range[1] / dim2size);
    bins = new TwoDimensionalArray(1 + dim1maxBin - dim1minBin, 1 + dim2maxBin - dim2minBin, function(d1, d2) {
      var ret;
      ret = [];
      ret.dim1range = [d1 * dim1size, (d1 + 1) * dim1size];
      ret.dim2range = [d2 * dim1size, (d2 + 1) * dim2size];
      return ret;
    });
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      datum = data[_i];
      d1 = (~~(datum[dim1] / dim1size)) + Math.abs(dim1minBin);
      d2 = (~~(datum[dim2] / dim2size)) + Math.abs(dim2minBin);
      try {
        bins[d1][d2].push(datum);
      } catch (_error) {
        throw new Error("push failed on " + d1 + ", " + d2);
      }
    }
    return {
      bins: bins,
      dim: {
        dim1: dim1,
        dim2: dim2,
        dim1range: dim1range,
        dim2range: dim2range,
        dim1size: dim1size,
        dim2size: dim2size
      }
    };
  };

  dataToBins = function(msg) {
    var binDim, cleanShooting, minimalBins, pctBins, postMsg, rawShootingCollection, res, shotBins, threshold;
    rawShootingCollection = collectify(msg.data.resultSets[0].headers, msg.data.resultSets[0].rowSet);
    cleanShooting = [];
    rawShootingCollection.forEach(function(shot) {
      var newShot;
      newShot = {};
      newShot.m = shot.SHOT_MADE_FLAG;
      newShot.x = shot.LOC_X;
      newShot.y = shot.LOC_Y;
      newShot.v = parseInt(shot.SHOT_TYPE.charAt(0));
      return cleanShooting.push(newShot);
    });
    res = toBins(cleanShooting, msg.binOpts);
    shotBins = res.bins;
    binDim = res.dim;
    pctBins = shotBins.map(function(shots, x, y) {
      var bin, made, total;
      if (shots.length) {
        bin = {};
        total = shots.length;
        made = shots.filter(function(s) {
          return s.m;
        }).length;
        bin.a = shots.length;
        bin.p = parseFloat(made / total).toFixed(4);
        bin.x = x;
        bin.y = y;
        bin.v = shots[0].v;
        bin.e = bin.p * bin.v;
        return bin;
      } else {
        return false;
      }
    });
    threshold = msg.binOpts.threshold || 1;
    minimalBins = _(pctBins).flatten().filter(function(b) {
      return b.a >= threshold;
    }).value();
    postMsg = {
      type: "result",
      msg: {
        bins: minimalBins,
        dim: binDim
      }
    };
    self.postMessage(postMsg);
    return self.close();
  };

}).call(this);
